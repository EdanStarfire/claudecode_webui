class I{diff(e,t,n={}){let i;typeof n=="function"?(i=n,n={}):"callback"in n&&(i=n.callback);const a=this.castInput(e,n),s=this.castInput(t,n),r=this.removeEmpty(this.tokenize(a,n)),c=this.removeEmpty(this.tokenize(s,n));return this.diffWithOptionsObj(r,c,n,i)}diffWithOptionsObj(e,t,n,i){var a;const s=l=>{if(l=this.postProcess(l,n),i){setTimeout(function(){i(l)},0);return}else return l},r=t.length,c=e.length;let f=1,u=r+c;n.maxEditLength!=null&&(u=Math.min(u,n.maxEditLength));const P=(a=n.timeout)!==null&&a!==void 0?a:1/0,C=Date.now()+P,h=[{oldPos:-1,lastComponent:void 0}];let w=this.extractCommon(h[0],t,e,0,n);if(h[0].oldPos+1>=c&&w+1>=r)return s(this.buildValues(h[0].lastComponent,t,e));let p=-1/0,L=1/0;const v=()=>{for(let l=Math.max(p,-f);l<=Math.min(L,f);l+=2){let d;const m=h[l-1],g=h[l+1];m&&(h[l-1]=void 0);let k=!1;if(g){const y=g.oldPos-l;k=g&&0<=y&&y<r}const x=m&&m.oldPos+1<c;if(!k&&!x){h[l]=void 0;continue}if(!x||k&&m.oldPos<g.oldPos?d=this.addToPath(g,!0,!1,0,n):d=this.addToPath(m,!1,!0,1,n),w=this.extractCommon(d,t,e,l,n),d.oldPos+1>=c&&w+1>=r)return s(this.buildValues(d.lastComponent,t,e))||!0;h[l]=d,d.oldPos+1>=c&&(L=Math.min(L,l-1)),w+1>=r&&(p=Math.max(p,l+1))}f++};if(i)(function l(){setTimeout(function(){if(f>u||Date.now()>C)return i(void 0);v()||l()},0)})();else for(;f<=u&&Date.now()<=C;){const l=v();if(l)return l}}addToPath(e,t,n,i,a){const s=e.lastComponent;return s&&!a.oneChangePerToken&&s.added===t&&s.removed===n?{oldPos:e.oldPos+i,lastComponent:{count:s.count+1,added:t,removed:n,previousComponent:s.previousComponent}}:{oldPos:e.oldPos+i,lastComponent:{count:1,added:t,removed:n,previousComponent:s}}}extractCommon(e,t,n,i,a){const s=t.length,r=n.length;let c=e.oldPos,f=c-i,u=0;for(;f+1<s&&c+1<r&&this.equals(n[c+1],t[f+1],a);)f++,c++,u++,a.oneChangePerToken&&(e.lastComponent={count:1,previousComponent:e.lastComponent,added:!1,removed:!1});return u&&!a.oneChangePerToken&&(e.lastComponent={count:u,previousComponent:e.lastComponent,added:!1,removed:!1}),e.oldPos=c,f}equals(e,t,n){return n.comparator?n.comparator(e,t):e===t||!!n.ignoreCase&&e.toLowerCase()===t.toLowerCase()}removeEmpty(e){const t=[];for(let n=0;n<e.length;n++)e[n]&&t.push(e[n]);return t}castInput(e,t){return e}tokenize(e,t){return Array.from(e)}join(e){return e.join("")}postProcess(e,t){return e}get useLongestToken(){return!1}buildValues(e,t,n){const i=[];let a;for(;e;)i.push(e),a=e.previousComponent,delete e.previousComponent,e=a;i.reverse();const s=i.length;let r=0,c=0,f=0;for(;r<s;r++){const u=i[r];if(u.removed)u.value=this.join(n.slice(f,f+u.count)),f+=u.count;else{if(!u.added&&this.useLongestToken){let P=t.slice(c,c+u.count);P=P.map(function(C,h){const w=n[f+h];return w.length>C.length?w:C}),u.value=this.join(P)}else u.value=this.join(t.slice(c,c+u.count));c+=u.count,u.added||(f+=u.count)}}return i}}class T extends I{constructor(){super(...arguments),this.tokenize=F}equals(e,t,n){return n.ignoreWhitespace?((!n.newlineIsToken||!e.includes(`
`))&&(e=e.trim()),(!n.newlineIsToken||!t.includes(`
`))&&(t=t.trim())):n.ignoreNewlineAtEof&&!n.newlineIsToken&&(e.endsWith(`
`)&&(e=e.slice(0,-1)),t.endsWith(`
`)&&(t=t.slice(0,-1))),super.equals(e,t,n)}}const D=new T;function j(o,e,t){return D.diff(o,e,t)}function F(o,e){e.stripTrailingCr&&(o=o.replace(/\r\n/g,`
`));const t=[],n=o.split(/(\n|\r\n)/);n[n.length-1]||n.pop();for(let i=0;i<n.length;i++){const a=n[i];i%2&&!e.newlineIsToken?t[t.length-1]+=a:t.push(a)}return t}const N={includeIndex:!0,includeUnderline:!0,includeFileHeaders:!0};function E(o,e,t,n,i,a,s){let r;s?typeof s=="function"?r={callback:s}:r=s:r={},typeof r.context>"u"&&(r.context=4);const c=r.context;if(r.newlineIsToken)throw new Error("newlineIsToken may not be used with patch-generation functions, only with diffing functions");if(r.callback){const{callback:u}=r;j(t,n,Object.assign(Object.assign({},r),{callback:P=>{const C=f(P);u(C)}}))}else return f(j(t,n,r));function f(u){if(!u)return;u.push({value:"",lines:[]});function P(l){return l.map(function(d){return" "+d})}const C=[];let h=0,w=0,p=[],L=1,v=1;for(let l=0;l<u.length;l++){const d=u[l],m=d.lines||H(d.value);if(d.lines=m,d.added||d.removed){if(!h){const g=u[l-1];h=L,w=v,g&&(p=c>0?P(g.lines.slice(-c)):[],h-=p.length,w-=p.length)}for(const g of m)p.push((d.added?"+":"-")+g);d.added?v+=m.length:L+=m.length}else{if(h)if(m.length<=c*2&&l<u.length-2)for(const g of P(m))p.push(g);else{const g=Math.min(m.length,c);for(const x of P(m.slice(0,g)))p.push(x);const k={oldStart:h,oldLines:L-h+g,newStart:w,newLines:v-w+g,lines:p};C.push(k),h=0,w=0,p=[]}L+=m.length,v+=m.length}}for(const l of C)for(let d=0;d<l.lines.length;d++)l.lines[d].endsWith(`
`)?l.lines[d]=l.lines[d].slice(0,-1):(l.lines.splice(d+1,0,"\\ No newline at end of file"),d++);return{oldFileName:o,newFileName:e,oldHeader:i,newHeader:a,hunks:C}}}function b(o,e){if(e||(e=N),Array.isArray(o)){if(o.length>1&&!e.includeFileHeaders)throw new Error("Cannot omit file headers on a multi-file patch. (The result would be unparseable; how would a tool trying to apply the patch know which changes are to which file?)");return o.map(n=>b(n,e)).join(`
`)}const t=[];e.includeIndex&&o.oldFileName==o.newFileName&&t.push("Index: "+o.oldFileName),e.includeUnderline&&t.push("==================================================================="),e.includeFileHeaders&&(t.push("--- "+o.oldFileName+(typeof o.oldHeader>"u"?"":"	"+o.oldHeader)),t.push("+++ "+o.newFileName+(typeof o.newHeader>"u"?"":"	"+o.newHeader)));for(let n=0;n<o.hunks.length;n++){const i=o.hunks[n];i.oldLines===0&&(i.oldStart-=1),i.newLines===0&&(i.newStart-=1),t.push("@@ -"+i.oldStart+","+i.oldLines+" +"+i.newStart+","+i.newLines+" @@");for(const a of i.lines)t.push(a)}return t.join(`
`)+`
`}function A(o,e,t,n,i,a,s){if(typeof s=="function"&&(s={callback:s}),s?.callback){const{callback:r}=s;E(o,e,t,n,i,a,Object.assign(Object.assign({},s),{callback:c=>{r(c?b(c,s.headerOptions):void 0)}}))}else{const r=E(o,e,t,n,i,a,s);return r?b(r,s?.headerOptions):void 0}}function S(o,e,t,n,i,a){return A(o,o,e,t,n,i,a)}function H(o){const e=o.endsWith(`
`),t=o.split(`
`).map(n=>n+`
`);return e?t.pop():t.push(t.pop().slice(0,-1)),t}function M(o){return o&&o.__esModule&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o}export{S as c,M as g};
